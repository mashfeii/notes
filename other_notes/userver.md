---
id: userver
aliases: []
tags: []
---

# Построение своего "Мини-такси"

Для примера использовано приложение такси яндекса:

- 700 000 зарегистрированных пользователей, учитывается, что половина из них на линии
- К системе запросы поступают раз в секунду - 350 000 запросов/сек.

1 вариант: один сервер
Невыгодно из-за слишком большой нагрузки

2 вариант: разделение на микросервисы, разделение нагрузки по разным серверам
Лучше, выгоднее, производительнее - нагрузка снижается до 35 000 запросов/сек.
Однако, практика показывает, что превышение 10 000 запросов/сек. делает систему неэффективной

## Из-за чего снижается производительность после 10 000 запросов/сек.

На практике первые решения были синхронными серверами (наивный подход)
Такой код легко читается, но медленно работает из-за того, что код делает множество вызовов к
операционной системе (что уже является дорогостоящей операцией), к тому же, останавливает выполнение
программы до момента получения реальных данных

## Решение данной проблемы

Было (в наивном решении):

- Отдаём управление ОС при системном вызове
- Ждём пока событие случится
- ОС будит поток

Станет (в актуальном решении):

- "Забираем" **случившиеся** события
- Выполняем коллбеки, связанные с этим событием

```cpp
void async_accept() {
  accept(listener, [](socket_t socket) {
    async_accept();
      socket.receive(
        [socket](std::vector<unsigned char> data) {
          process(data);
          socket.send(data, kNoCallback);
        });
  });
}
```

## Корутины

Корутины выглядят как обычный синхронный код, за исключением ключевых слов, благодаря которым
компилятор превращает его в асинхронный = эффективный, но сохраняется читабельность

```cpp
coro_future coro_accpet_stackles() {
  for(;;) {
    auto new_socket = co_await accept(listener);

    auto task = Async([socket = std::move(new_socket)]() -> coro_future {
      auto data = co_await socket.receive();
      process(data);
      co_await socket.send(data);
      co_return;
    });

    task.Detach();
  }
}
```

## Userver - первые шаги

Все клиенты, которые обращаются к серверу: в веб или мобильном приложении, другой сервер, так далее
являются `clients::http::Client`
